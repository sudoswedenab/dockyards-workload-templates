// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go k8s.io/kubernetes/pkg/apis/rbac

package rbac

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

#APIGroupAll:        "*"
#ResourceAll:        "*"
#VerbAll:            "*"
#NonResourceAll:     "*"
#GroupKind:          "Group"
#ServiceAccountKind: "ServiceAccount"
#UserKind:           "User"

// AutoUpdateAnnotationKey is the name of an annotation which prevents reconciliation if set to "false"
#AutoUpdateAnnotationKey: "rbac.authorization.kubernetes.io/autoupdate"

// PolicyRule holds information that describes a policy rule, but does not contain information
// about who the rule applies to or which namespace the rule applies to.
#PolicyRule: {
	// Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
	Verbs: [...string] @go(,[]string)

	// APIGroups is the name of the APIGroup that contains the resources.
	// If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
	APIGroups: [...string] @go(,[]string)

	// Resources is a list of resources this rule applies to.  '*' represents all resources in the specified apiGroups.
	// '*/foo' represents the subresource 'foo' for all resources in the specified apiGroups.
	Resources: [...string] @go(,[]string)

	// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
	ResourceNames: [...string] @go(,[]string)

	// NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
	// If an action is not a resource API request, then the URL is split on '/' and is checked against the NonResourceURLs to look for a match.
	// Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
	// Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
	NonResourceURLs: [...string] @go(,[]string)
}

// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
// or a value for non-objects such as user and group names.
#Subject: {
	// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
	// If the Authorizer does not recognized the kind value, the Authorizer should report an error.
	Kind: string

	// APIGroup holds the API group of the referenced subject.
	// Defaults to "" for ServiceAccount subjects.
	// Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
	APIGroup: string

	// Name of the object being referenced.
	Name: string

	// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
	// the Authorizer should report an error.
	Namespace: string
}

// RoleRef contains information that points to the role being used
#RoleRef: {
	// APIGroup is the group for the resource being referenced
	APIGroup: string

	// Kind is the type of resource being referenced
	Kind: string

	// Name is the name of resource being referenced
	Name: string
}

// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
#Role: {
	TypeMeta: metav1.#TypeMeta

	// Standard object's metadata.
	ObjectMeta: metav1.#ObjectMeta

	// Rules holds all the PolicyRules for this Role
	Rules: [...#PolicyRule] @go(,[]PolicyRule)
}

// RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace.
// It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given
// namespace only have effect in that namespace.
#RoleBinding: {
	TypeMeta:   metav1.#TypeMeta
	ObjectMeta: metav1.#ObjectMeta

	// Subjects holds references to the objects the role applies to.
	Subjects: [...#Subject] @go(,[]Subject)

	// RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace.
	// If the RoleRef cannot be resolved, the Authorizer must return an error.
	// This field is immutable.
	RoleRef: #RoleRef
}

// RoleBindingList is a collection of RoleBindings
#RoleBindingList: {
	TypeMeta: metav1.#TypeMeta

	// Standard object's metadata.
	ListMeta: metav1.#ListMeta

	// Items is a list of roleBindings
	Items: [...#RoleBinding] @go(,[]RoleBinding)
}

// RoleList is a collection of Roles
#RoleList: {
	TypeMeta: metav1.#TypeMeta

	// Standard object's metadata.
	ListMeta: metav1.#ListMeta

	// Items is a list of roles
	Items: [...#Role] @go(,[]Role)
}

// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
#ClusterRole: {
	TypeMeta: metav1.#TypeMeta

	// Standard object's metadata.
	ObjectMeta: metav1.#ObjectMeta

	// Rules holds all the PolicyRules for this ClusterRole
	Rules: [...#PolicyRule] @go(,[]PolicyRule)

	// AggregationRule is an optional field that describes how to build the Rules for this ClusterRole.
	// If AggregationRule is set, then the Rules are controller managed and direct changes to Rules will be
	// stomped by the controller.
	AggregationRule?: null | #AggregationRule @go(,*AggregationRule)
}

// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
#AggregationRule: {
	// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules.
	// If any of the selectors match, then the ClusterRole's permissions will be added
	ClusterRoleSelectors: [...metav1.#LabelSelector] @go(,[]metav1.LabelSelector)
}

// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace,
// and adds who information via Subject.
#ClusterRoleBinding: {
	TypeMeta: metav1.#TypeMeta

	// Standard object's metadata.
	ObjectMeta: metav1.#ObjectMeta

	// Subjects holds references to the objects the role applies to.
	Subjects: [...#Subject] @go(,[]Subject)

	// RoleRef can only reference a ClusterRole in the global namespace.
	// If the RoleRef cannot be resolved, the Authorizer must return an error.
	// This field is immutable.
	RoleRef: #RoleRef
}

// ClusterRoleBindingList is a collection of ClusterRoleBindings
#ClusterRoleBindingList: {
	TypeMeta: metav1.#TypeMeta

	// Standard object's metadata.
	ListMeta: metav1.#ListMeta

	// Items is a list of ClusterRoleBindings
	Items: [...#ClusterRoleBinding] @go(,[]ClusterRoleBinding)
}

// ClusterRoleList is a collection of ClusterRoles
#ClusterRoleList: {
	TypeMeta: metav1.#TypeMeta

	// Standard object's metadata.
	ListMeta: metav1.#ListMeta

	// Items is a list of ClusterRoles
	Items: [...#ClusterRole] @go(,[]ClusterRole)
}
